(load "../sdf/manager/load")
(manage 'new-environment 'combinators)

(define min-arity-table (make-key-weak-eqv-hash-table))
(define max-arity-table (make-key-weak-eqv-hash-table))

(define (restrict-min-arity proc nargs)
  (hash-table-set! min-arity-table proc nargs)
  proc)

(define (restrict-max-arity proc nargs)
  (hash-table-set! max-arity-table proc nargs)
  proc)

(define (get-min-arity proc)
  (or (hash-table-ref/default min-arity-table proc #f)
      (let ((a (procedure-arity proc)))
        (procedure-arity-min a))))

(define (get-max-arity proc)
  (or (hash-table-ref/default max-arity-table proc #f)
      (let ((a (procedure-arity proc)))
	(procedure-arity-max a))))

(define (parallel-apply f g)
  (assert (eqv? (get-min-arity f) (get-min-arity g)))
  (assert (eqv? (get-max-arity f) (get-max-arity g)))
  (let ((n (get-min-arity f))
        (m (get-max-arity f)))
    (define (the-combination . args)
      (assert (and (<= n (length args)) (or (not m) (>= m (length args)))))
      (let-values ((fv (apply f args))
		   (gv (apply g args)))
      	(apply values (append gv fv))))
    (restrict-min-arity the-combination n)
    (restrict-max-arity the-combination m)))

(define (compose f g)
  (define (the-composition . args)
    (call-with-values (lambda () (apply f args))
      g))
  (restrict-min-arity the-composition (get-min-arity f))
  (restrict-max-arity the-composition (get-max-arity f)))

(define (discard-argument i)
  (assert (exact-nonnegative-integer? i))
  (define (args-manipulator . args)
    (apply values (list-remove args i)))
  (restrict-min-arity args-manipulator 0)
  (restrict-max-arity args-manipulator #f))

(define (discard-arguments . args)
  (let ((sorted-args (quick-sort args <)))
    (define (discard n)
      (if (= (length sorted-args) (+ n 1))
	(discard-argument (list-ref sorted-args n))
	(compose (discard-argument (list-ref sorted-args n)) 
		 (discard (+ n 1)))))
    (lambda (f) 
      (let ((m (+ (get-arity f) (length args))))
	(define (the-combination . callargs)
	  (assert (= (length callargs) m))
	  (apply (compose (discard 0) f) callargs))
	(restrict-arity the-combination m)))))

(define ((curry-argumenti-book i) . args)
  (lambda (f)
    (assert (= (length args) (- (get-arity f) 1)))
    (lambda (x)
      (apply f (list-insert args i x)))))

(define ((curry-argument i) . args)
  (lambda (x)
    (list-insert args i x)))

(define ((curry-arguments . i) . args)
  (define (curry n rargs cargs) 
    (if (= (+ n 1) (length i))
      (list-insert rargs (list-ref i n) (list-ref cargs n))
      (curry (+ n 1) (list-insert rargs (list-ref i n) (list-ref cargs n)) cargs)))
  (lambda (f)
    (assert (= (get-arity f) (+ (length i) (length args))))
    (let ((m (length i)))
      (define (the-combination . callargs)
	(apply f (curry 0 args callargs)))
      (restrict-arity the-combination m))))


(define (compose-variadic . funcs)
  (assert (> (length funcs) 1))
  (define (comp functions)
    (if (= (length functions) 2)
      (compose (list-ref functions 0) (list-ref functions 1))
      (compose (car functions) (comp (cdr functions)))))
  (comp funcs))

;;; test
(((discard-arguments 2)
  (lambda (x y z) (list 'foo x y z)))
 'a 'b 'c 'd)

(((discard-arguments 2 1)
  (lambda (x y) (list 'foo x y)))
 'a 'b 'c 'd)

((((curry-arguments 2)
   'a 'b 'c)
  (lambda (x y z w)
    (list 'foo x y z w)))
 'd)
'expect-value: '(foo a b d c)

((((curry-arguments 2 1)
   'a 'b)
  (lambda (x y z w)
    (list 'foo x y z w)))
 'd 'c)
'expect-value: '(foo a c b d)

((((curry-arguments 2 1 2)
   'a 'b)
  (lambda (x y z v w)
    (list 'foo x y z v w)))
 'c 'd 'e)
'expect-value: '(foo a d e b c)

((compose-variadic (lambda (x) (+ x 1))
		   (lambda (x) (+ x 2))
		   (lambda (x) (+ x 3))) 10)
